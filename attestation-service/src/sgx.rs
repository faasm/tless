use crate::{
    ecdhe,
    intel::{INTEL_PCS_URL, IntelCa, SgxCollateral, SgxQuote},
    jwt::{self, JwtClaims},
    mock::{MockQuote, MockQuoteType},
    request::{NodeData, Tee},
    state::AttestationServiceState,
};
use anyhow::Result;
use axum::{Extension, Json, http::StatusCode, response::IntoResponse};
use base64::{Engine as _, engine::general_purpose};
use log::{debug, error, info};
use serde::Deserialize;
use serde_json::json;
use std::{
    str::FromStr,
    sync::Arc,
    time::{SystemTime, UNIX_EPOCH},
};

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct InitTimeData {
    _data: String,
    _data_type: String,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct RuntimeData {
    data: String,
    _data_type: String,
}

/// # Description
///
/// This struct corresponds to the request that SGX-Faasm sends to verify an SGX
/// report. Some of the fields are legacy from when we used Azure's Attestation
/// Service, and they are now unused. The implementation of the client-side
/// protocol is upstreamed in Faasm, because it relies on coordination from
/// inside/outside the Faaslet (i.e. WASM module) and inside/outside the SGX
/// enclave. We provide a mock implementation of the SGX client with Accless'
/// attestation library for testing purposes.
#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SgxRequest {
    _draft_policy_for_attestation: String,
    /// Attributes used for CP-ABE keygen.
    node_data: NodeData,
    _init_time_data: InitTimeData,
    /// Base64-encoded SGX quote as generated by the Quoting Enclave.
    quote: String,
    /// Additional base64-encoded data that we send with the enclave as part of
    /// the enclave held data. Even if slightly redundant, it is easier to
    /// access as a standalone field, and we check its integrity from the
    /// quote itself, which is signed by the QE.
    runtime_data: RuntimeData,
}

/// # Description
///
/// Helper method to fetch the SGX quote collateral. This is the information we
/// need to validate that the quote is correct. We need to fetch it once per
/// TCB, but then we can cache it for subsequent requests.
///
/// In Azure, in general, we can use a Provisioning Certificate Caching Service
/// (PCCS) that prevents having to send a request to Intel for the collateral.
///
/// # Arguments
///
/// - `cache_key`: key in the SGX collateral cache that indicates the TCB of the
///   quote we are trying to validate. It comes from the SGX quote itself.
/// - `state`: handle to the state that contains the SGX quote cache.
///
/// # Returns
///
/// The SGX collateral, either read from the cache, or fetched from Intel's PCS
/// or a cloud-based PCCS.
async fn get_sgx_collateral(
    cache_key: (String, IntelCa),
    state: &Arc<AttestationServiceState>,
) -> Result<SgxCollateral> {
    // Fast path: read collateral from the cache.
    let maybe_collateral: Option<SgxCollateral> = {
        let cache = state.sgx_collateral_cache.read().await;
        cache.get(&cache_key).cloned()
    };

    if let Some(collateral) = maybe_collateral {
        return Ok(collateral);
    };

    // Slow path: fetch collateral from either Intel's PCS or a cloud's PCCS.
    let pccs_url: Option<&str> = state.sgx_pccs_url.as_deref().and_then(|path| path.to_str());

    let collateral: SgxCollateral = if let Some(pccs_url) = pccs_url {
        debug!("fetching SGX collateral from PCCS (url={pccs_url})");
        dcap_qvl::collateral::get_collateral_for_fmspc(
            pccs_url,
            cache_key.0.clone(),
            cache_key.1.as_str(),
            true,
        )
        .await
        .map_err(|e| {
            anyhow::anyhow!("Error fetching SGX collateral from PCCS (url={pccs_url}, error={e:?})")
        })?
    } else {
        debug!("fetching SGX collateral from Intel's PCS (url={INTEL_PCS_URL})");
        dcap_qvl::collateral::get_collateral_for_fmspc(
            INTEL_PCS_URL,
            cache_key.0.clone(),
            cache_key.1.as_str(),
            true,
        )
        .await
        .map_err(|e| {
            anyhow::anyhow!("Error fetching SGX collateral from Intel's PCS (error={e:?})")
        })?
    };

    // Cache collateral for future use.
    {
        let mut cache = state.sgx_collateral_cache.write().await;
        cache.insert(cache_key, collateral.clone());
    }

    Ok(collateral)
}

/// # Description
///
/// Entrypoint function to verify an SGX report.
pub async fn verify_sgx_report(
    Extension(state): Extension<Arc<AttestationServiceState>>,
    Json(payload): Json<SgxRequest>,
) -> impl IntoResponse {
    // Decode the quote
    // WARNING: we must use URL_SAFE as on the client side we are encoding
    // with cppcodec::base64_url
    let raw_quote_b64 = payload.quote.replace(['\n', '\r'], "");
    let quote_bytes = match general_purpose::URL_SAFE.decode(&raw_quote_b64) {
        Ok(bytes) => bytes,
        Err(e) => {
            error!("invalid base64 string in SGX quote (error={e:?})");
            return (
                StatusCode::BAD_REQUEST,
                Json(json!({ "error": "invalid base64 in quote" })),
            );
        }
    };

    let report_data_bytes: Vec<u8> = if state.mock_attestation {
        match MockQuote::from_bytes(&quote_bytes) {
            Ok(mock_quote) => {
                if mock_quote.quote_type != MockQuoteType::Sgx {
                    error!("invalid mock SGX quote (error=wrong quote type)");
                    return (
                        StatusCode::BAD_REQUEST,
                        Json(json!({ "error": "invalid mock SGX quote" })),
                    );
                }
                info!("received mock SGX quote, skipping DCAP verification");
                mock_quote.user_data
            }
            Err(e) => {
                error!("invalid mock SGX quote (error={e:?})");
                return (
                    StatusCode::BAD_REQUEST,
                    Json(json!({ "error": "invalid mock SGX quote" })),
                );
            }
        }
    } else {
        // Parse the bytes into an SgxQuote structure.
        let sgx_quote: SgxQuote = match SgxQuote::parse(&quote_bytes) {
            Ok(sgx_quote) => sgx_quote,
            Err(e) => {
                error!("error parsing SGX quote (error={e:?})");
                return (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(json!({ "error": "error parsing SGX quote" })),
                );
            }
        };

        // Extract the key we use in the collateral cache.
        let sgx_tcb_key: (String, IntelCa) = match (sgx_quote.fmspc(), sgx_quote.ca()) {
            (Ok(sgx_fmpsc), Ok(sgx_ca)) => match IntelCa::from_str(sgx_ca) {
                Ok(parsed_ca) => (hex::encode_upper(sgx_fmpsc), parsed_ca),
                Err(_) => {
                    error!("invalid CA returned by SGX quote: {sgx_ca}");
                    return (
                        StatusCode::INTERNAL_SERVER_ERROR,
                        Json(json!({ "error": "invalid CA in SGX quote" })),
                    );
                }
            },
            _ => {
                error!("error extracting FMSPC and CA from SGX quote");
                return (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(json!({ "error": "error extracting CA and FMSPC from SGX quote" })),
                );
            }
        };

        // Fetch the collateral to validate the quote.
        let collateral: SgxCollateral = match get_sgx_collateral(sgx_tcb_key, &state).await {
            Ok(collateral) => collateral,
            Err(e) => {
                error!("error fetching SGX collateral (error={e:?})");
                return (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(json!({ "error": "error fetching SGX collateral" })),
                );
            }
        };

        let now = match SystemTime::now().duration_since(UNIX_EPOCH) {
            Ok(t) => t.as_secs(),
            Err(e) => {
                error!("error getting time since epoch (error={e:?})");
                return (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(json!({ "error": "error getting time since epoch" })),
                );
            }
        };
        // FIXME(#55): also check the MRENCLAVE measurement against a reference value.
        let verified_report = match dcap_qvl::verify::verify(&quote_bytes, &collateral, now) {
            Ok(tcb) => tcb,
            Err(e) => {
                error!("failed to verify SGX's quote (error={e:?})");
                return (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(json!({ "error": "failed to verify SGX quote" })),
                );
            }
        };
        info!("verififed sgx report (status={})", verified_report.status);

        match verified_report.report {
            dcap_qvl::quote::Report::SgxEnclave(enclave_report) => {
                enclave_report.report_data.to_vec()
            }
            _ => {
                error!("received TDX report instead of SGX one");
                return (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(json!({ "error": "received TDX report instead of SGX one" })),
                );
            }
        }
    };

    // Use the enclave held data (runtime_data) public key, to derive an
    // encryption key to protect the returned JWT, which contains secrets.
    debug!("decoding base64 encoded public key in quote.runtime_data");
    let raw_pubkey_bytes = match general_purpose::URL_SAFE.decode(&payload.runtime_data.data) {
        Ok(b) => b,
        Err(_) => {
            return (
                StatusCode::BAD_REQUEST,
                Json(json!({ "error": "invalid base64 in runtimeData.data" })),
            );
        }
    };

    // Verify that the raw-bytes included in the runtime data match the enclave held
    // data in the verified report.
    if raw_pubkey_bytes != report_data_bytes {
        error!(
            "enclave held data does not match verified report data (expected={raw_pubkey_bytes:?}, got={:?})",
            report_data_bytes
        );
        return (
            StatusCode::BAD_REQUEST,
            Json(json!({ "error": "enclave held data does not match verified report data" })),
        );
    }

    debug!("parsing pub key bytes to SEC1 format");
    let pubkey_bytes = match ecdhe::raw_pubkey_to_sec1_format(&raw_pubkey_bytes) {
        Some(b) => b,
        None => {
            error!("error converting SGX public key to SEC1 format");
            return (
                StatusCode::BAD_REQUEST,
                Json(json!({ "error": "invalid public key length" })),
            );
        }
    };
    if !ecdhe::is_valid_p256_point(&pubkey_bytes) {
        error!("error validating SGX-provided public key");
        return (
            StatusCode::BAD_REQUEST,
            Json(json!({ "error": "invalid EC public key" })),
        );
    }

    let (server_pub_key, shared_secret) =
        match ecdhe::generate_ecdhe_keys_and_derive_secret(&pubkey_bytes) {
            Ok(res) => res,
            Err(e) => {
                error!("error generating ECDH keys or deriving secret (error={e:?})");
                return (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(json!({ "error": "key generation or derivation failed" })),
                );
            }
        };

    let server_pub_key_le = ecdhe::sec1_pubkey_to_raw(&server_pub_key).unwrap();
    let server_pub_b64 = general_purpose::STANDARD.encode(server_pub_key_le);

    debug!("encoding JWT with server's private key (for authenticity)");
    let claims = match JwtClaims::new(
        &state,
        &Tee::Sgx,
        &payload.node_data.gid,
        &payload.node_data.workflow_id,
        &payload.node_data.node_id,
    ) {
        Ok(claims) => claims,
        Err(e) => {
            error!("error gathering JWT claims (error={e:?})");
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(json!({ "error": "JWT claims gathering" })),
            );
        }
    };
    let header = jsonwebtoken::Header {
        alg: jsonwebtoken::Algorithm::RS256,
        ..Default::default()
    };
    let jwt = match jsonwebtoken::encode(&header, &claims, &state.jwt_encoding_key) {
        Ok(t) => t,
        Err(e) => {
            error!("JWT encode error (error={e:?})");
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(json!({ "error": "JWT encoding failed" })),
            );
        }
    };

    match jwt::encrypt_jwt(jwt, shared_secret, server_pub_b64) {
        Ok(response) => (StatusCode::OK, Json(response)),
        Err(e) => {
            error!("error encrypting JWT (error={e:?})");
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(json!({ "error": "JWT encryption failed" })),
            )
        }
    }
}
